/// AUTO GENERATED FILE, DO NOT EDIT.
///
/// Generated by `package:ffigen`.
// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart';

import 'libc.dart';

class Unistd {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  Unistd() : _dylib = Libc().dylib;

  /// Test for access to NAME using the real UID and real GID.
  int access(
    String name, // ffi.Pointer<ffi.Int8> __name,
    int type,
  ) {
    _access ??= _dylib.lookupFunction<_c_access, _dart_access>('access');

    var c_name = Utf8.toUtf8(name);
    var result = _access(
      c_name,
      type,
    );

    free(c_name);

    return result;
  }

  _dart_access _access;

  /// Test for access to FILE relative to the directory FD is open on.
  /// If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
  /// otherwise use real IDs like `access'.
  int faccessat(
    int fd,
    String filename, // ffi.Pointer<ffi.Int8> __file,
    int type,
    int flag,
  ) {
    _faccessat ??=
        _dylib.lookupFunction<_c_faccessat, _dart_faccessat>('faccessat');

    var c_filename = Utf8.toUtf8(filename);
    var result = _faccessat(
      fd,
      c_filename,
      type,
      flag,
    );

    free(c_filename);

    return result;
  }

  _dart_faccessat _faccessat;

  int lseek(
    int __fd,
    int __offset,
    int __whence,
  ) {
    _lseek ??= _dylib.lookupFunction<_c_lseek, _dart_lseek>('lseek');
    return _lseek(
      __fd,
      __offset,
      __whence,
    );
  }

  _dart_lseek _lseek;

  /// Close the file descriptor FD.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int close(
    int __fd,
  ) {
    _close ??= _dylib.lookupFunction<_c_close, _dart_close>('close');
    return _close(
      __fd,
    );
  }

  _dart_close _close;

  /// Read NBYTES into BUF from FD.  Return the
  /// number read, -1 for errors or 0 for EOF.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int read(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    _read ??= _dylib.lookupFunction<_c_read, _dart_read>('read');
    return _read(
      __fd,
      __buf,
      __nbytes,
    );
  }

  _dart_read _read;

  /// Write N bytes of BUF to FD.  Return the number written, or -1.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int write(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __n,
  ) {
    _write ??= _dylib.lookupFunction<_c_write, _dart_write>('write');
    return _write(
      __fd,
      __buf,
      __n,
    );
  }

  _dart_write _write;

  /// Read NBYTES into BUF from FD at the given position OFFSET without
  /// changing the file pointer.  Return the number read, -1 for errors
  /// or 0 for EOF.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int pread(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
    int __offset,
  ) {
    _pread ??= _dylib.lookupFunction<_c_pread, _dart_pread>('pread');
    return _pread(
      __fd,
      __buf,
      __nbytes,
      __offset,
    );
  }

  _dart_pread _pread;

  /// Write N bytes of BUF to FD at the given position OFFSET without
  /// changing the file pointer.  Return the number written, or -1.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int pwrite(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __n,
    int __offset,
  ) {
    _pwrite ??= _dylib.lookupFunction<_c_pwrite, _dart_pwrite>('pwrite');
    return _pwrite(
      __fd,
      __buf,
      __n,
      __offset,
    );
  }

  _dart_pwrite _pwrite;

  /// Create a one-way communication channel (pipe).
  /// If successful, two file descriptors are stored in PIPEDES;
  /// bytes written on PIPEDES[1] can be read from PIPEDES[0].
  /// Returns 0 if successful, -1 if not.
  int pipe(
    ffi.Pointer<ffi.Int32> __pipedes,
  ) {
    _pipe ??= _dylib.lookupFunction<_c_pipe, _dart_pipe>('pipe');
    return _pipe(
      __pipedes,
    );
  }

  _dart_pipe _pipe;

  /// Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
  /// If SECONDS is zero, any currently scheduled alarm will be cancelled.
  /// The function returns the number of seconds remaining until the last
  /// alarm scheduled would have signaled, or zero if there wasn't one.
  /// There is no return value to indicate an error, but you can set `errno'
  /// to 0 and check its value after calling `alarm', and this might tell you.
  /// The signal may come late due to processor scheduling.
  int alarm(
    int __seconds,
  ) {
    _alarm ??= _dylib.lookupFunction<_c_alarm, _dart_alarm>('alarm');
    return _alarm(
      __seconds,
    );
  }

  _dart_alarm _alarm;

  /// Make the process sleep for SECONDS seconds, or until a signal arrives
  /// and is not ignored.  The function returns the number of seconds less
  /// than SECONDS which it actually slept (thus zero if it slept the full time).
  /// If a signal handler does a `longjmp' or modifies the handling of the
  /// SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
  /// signal afterwards is undefined.  There is no return value to indicate
  /// error, but if `sleep' returns SECONDS, it probably didn't work.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int sleep(
    int __seconds,
  ) {
    _sleep ??= _dylib.lookupFunction<_c_sleep, _dart_sleep>('sleep');
    return _sleep(
      __seconds,
    );
  }

  _dart_sleep _sleep;

  /// Set an alarm to go off (generating a SIGALRM signal) in VALUE
  /// microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
  /// timer is reset to go off every INTERVAL microseconds thereafter.
  /// Returns the number of microseconds remaining before the alarm.
  int ualarm(
    int __value,
    int __interval,
  ) {
    _ualarm ??= _dylib.lookupFunction<_c_ualarm, _dart_ualarm>('ualarm');
    return _ualarm(
      __value,
      __interval,
    );
  }

  _dart_ualarm _ualarm;

  /// Sleep USECONDS microseconds, or until a signal arrives that is not blocked
  /// or ignored.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int usleep(
    int __useconds,
  ) {
    _usleep ??= _dylib.lookupFunction<_c_usleep, _dart_usleep>('usleep');
    return _usleep(
      __useconds,
    );
  }

  _dart_usleep _usleep;

  /// Suspend the process until a signal arrives.
  /// This always returns -1 and sets `errno' to EINTR.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int pause() {
    _pause ??= _dylib.lookupFunction<_c_pause, _dart_pause>('pause');
    return _pause();
  }

  _dart_pause _pause;

  /// Change the owner and group of FILE.
  int chown(
    String filename,
    int owner,
    int group,
  ) {
    var c_filename = Utf8.toUtf8(filename);

    _chown ??= _dylib.lookupFunction<_c_chown, _dart_chown>('chown');
    var results = _chown(
      c_filename,
      owner,
      group,
    );

    free(c_filename);
    return results;
  }

  _dart_chown _chown;

  /// Change the owner and group of the file that FD is open on.
  int fchown(
    int __fd,
    int __owner,
    int __group,
  ) {
    _fchown ??= _dylib.lookupFunction<_c_fchown, _dart_fchown>('fchown');
    return _fchown(
      __fd,
      __owner,
      __group,
    );
  }

  _dart_fchown _fchown;

  /// Change owner and group of FILE, if it is a symbolic
  /// link the ownership of the symbolic link is changed.
  int lchown(
    String filename, // ffi.Pointer<ffi.Int8> __file,
    int owner,
    int group,
  ) {
    var c_filename = Utf8.toUtf8(filename);

    _lchown ??= _dylib.lookupFunction<_c_lchown, _dart_lchown>('lchown');
    var result = _lchown(
      c_filename,
      owner,
      group,
    );

    free(c_filename);
    return result;
  }

  _dart_lchown _lchown;

  /// Change the owner and group of FILE relative to the directory FD is open
  /// on.
  int fchownat(
    int __fd,
    String filename, // ffi.Pointer<ffi.Int8> __file,
    int __owner,
    int __group,
    int __flag,
  ) {
    _fchownat ??=
        _dylib.lookupFunction<_c_fchownat, _dart_fchownat>('fchownat');

    var c_filename = Utf8.toUtf8(filename);
    var result = _fchownat(
      __fd,
      c_filename,
      __owner,
      __group,
      __flag,
    );

    free(c_filename);
    return result;
  }

  _dart_fchownat _fchownat;

  /// Change the process's working directory to PATH.
  int chdir(String path // ffi.Pointer<ffi.Int8> __path,
      ) {
    var c_path = Utf8.toUtf8(path);
    _chdir ??= _dylib.lookupFunction<_c_chdir, _dart_chdir>('chdir');
    var result = _chdir(
      c_path,
    );

    free(c_path);
    return result;
  }

  _dart_chdir _chdir;

  /// Change the process's working directory to the one FD is open on.
  int fchdir(
    int __fd,
  ) {
    _fchdir ??= _dylib.lookupFunction<_c_fchdir, _dart_fchdir>('fchdir');
    return _fchdir(
      __fd,
    );
  }

  _dart_fchdir _fchdir;

  /// Get the pathname of the current working directory,
  /// and put it in SIZE bytes of BUF.  Returns NULL if the
  /// directory couldn't be determined or SIZE was too small.
  /// If successful, returns BUF.  In GNU, if BUF is NULL,
  /// an array is allocated with `malloc'; the array is SIZE
  /// bytes long, unless SIZE == 0, in which case it is as
  /// big as necessary.
  String getcwd() {
    _getcwd ??= _dylib.lookupFunction<_c_getcwd, _dart_getcwd>('getcwd');
    var c_cwd = _getcwd(
      null,
      0,
    );

    var cwd = Utf8.fromUtf8(c_cwd);
    free(c_cwd);

    return cwd;
  }

  _dart_getcwd _getcwd;

  /// Put the absolute pathname of the current working directory in BUF.
  /// If successful, return BUF.  If not, put an error message in
  /// BUF and return NULL.  BUF should be at least PATH_MAX bytes long.
  String getwd() {
    var c_buf = allocate<Utf8>(count: PATH_MAX);
    _getwd ??= _dylib.lookupFunction<_c_getwd, _dart_getwd>('getwd');
    var result = _getwd(
      c_buf,
    );

    var wd = Utf8.fromUtf8(result);

    free(c_buf);

    return wd;
  }

  _dart_getwd _getwd;

  /// Duplicate FD, returning a new file descriptor on the same file.
  int dup(
    int __fd,
  ) {
    _dup ??= _dylib.lookupFunction<_c_dup, _dart_dup>('dup');
    return _dup(
      __fd,
    );
  }

  _dart_dup _dup;

  /// Duplicate FD to FD2, closing FD2 and making it open on the same file.
  int dup2(
    int __fd,
    int __fd2,
  ) {
    _dup2 ??= _dylib.lookupFunction<_c_dup2, _dart_dup2>('dup2');
    return _dup2(
      __fd,
      __fd2,
    );
  }

  _dart_dup2 _dup2;

  /// Replace the current process, executing PATH with arguments ARGV and
  /// environment ENVP.  ARGV and ENVP are terminated by NULL pointers.
  int execve(
    ffi.Pointer<ffi.Int8> __path,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __envp,
  ) {
    _execve ??= _dylib.lookupFunction<_c_execve, _dart_execve>('execve');
    return _execve(
      __path,
      __argv,
      __envp,
    );
  }

  _dart_execve _execve;

  /// Execute the file FD refers to, overlaying the running program image.
  /// ARGV and ENVP are passed to the new program, as for `execve'.
  int fexecve(
    int __fd,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __envp,
  ) {
    _fexecve ??= _dylib.lookupFunction<_c_fexecve, _dart_fexecve>('fexecve');
    return _fexecve(
      __fd,
      __argv,
      __envp,
    );
  }

  _dart_fexecve _fexecve;

  /// Execute PATH with arguments ARGV and environment from `environ'.
  int execv(
    ffi.Pointer<ffi.Int8> __path,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
  ) {
    _execv ??= _dylib.lookupFunction<_c_execv, _dart_execv>('execv');
    return _execv(
      __path,
      __argv,
    );
  }

  _dart_execv _execv;

  /// Execute PATH with all arguments after PATH until a NULL pointer,
  /// and the argument after that for environment.
  int execle(
    ffi.Pointer<ffi.Int8> __path,
    ffi.Pointer<ffi.Int8> __arg,
  ) {
    _execle ??= _dylib.lookupFunction<_c_execle, _dart_execle>('execle');
    return _execle(
      __path,
      __arg,
    );
  }

  _dart_execle _execle;

  /// Execute PATH with all arguments after PATH until
  /// a NULL pointer and environment from `environ'.
  int execl(
    ffi.Pointer<ffi.Int8> __path,
    ffi.Pointer<ffi.Int8> __arg,
  ) {
    _execl ??= _dylib.lookupFunction<_c_execl, _dart_execl>('execl');
    return _execl(
      __path,
      __arg,
    );
  }

  _dart_execl _execl;

  /// Execute FILE, searching in the `PATH' environment variable if it contains
  /// no slashes, with arguments ARGV and environment from `environ'.
  int execvp(
    ffi.Pointer<ffi.Int8> __file,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
  ) {
    _execvp ??= _dylib.lookupFunction<_c_execvp, _dart_execvp>('execvp');
    return _execvp(
      __file,
      __argv,
    );
  }

  _dart_execvp _execvp;

  /// Execute FILE, searching in the `PATH' environment variable if
  /// it contains no slashes, with all arguments after FILE until a
  /// NULL pointer and environment from `environ'.
  int execlp(
    ffi.Pointer<ffi.Int8> __file,
    ffi.Pointer<ffi.Int8> __arg,
  ) {
    _execlp ??= _dylib.lookupFunction<_c_execlp, _dart_execlp>('execlp');
    return _execlp(
      __file,
      __arg,
    );
  }

  _dart_execlp _execlp;

  /// Add INC to priority of the current process.
  int nice(
    int __inc,
  ) {
    _nice ??= _dylib.lookupFunction<_c_nice, _dart_nice>('nice');
    return _nice(
      __inc,
    );
  }

  _dart_nice _nice;

  /// Terminate program execution with the low-order 8 bits of STATUS.
  void exit(
    int status,
  ) {
    __exit ??= _dylib.lookupFunction<_c__exit, _dart__exit>('_exit');
    return __exit(
      status,
    );
  }

  _dart__exit __exit;

  /// Get file-specific configuration information about PATH.
  int pathconf(
    ffi.Pointer<ffi.Int8> __path,
    int __name,
  ) {
    _pathconf ??=
        _dylib.lookupFunction<_c_pathconf, _dart_pathconf>('pathconf');
    return _pathconf(
      __path,
      __name,
    );
  }

  _dart_pathconf _pathconf;

  /// Get file-specific configuration about descriptor FD.
  int fpathconf(
    int __fd,
    int __name,
  ) {
    _fpathconf ??=
        _dylib.lookupFunction<_c_fpathconf, _dart_fpathconf>('fpathconf');
    return _fpathconf(
      __fd,
      __name,
    );
  }

  _dart_fpathconf _fpathconf;

  /// Get the value of the system variable NAME.
  int sysconf(
    int __name,
  ) {
    _sysconf ??= _dylib.lookupFunction<_c_sysconf, _dart_sysconf>('sysconf');
    return _sysconf(
      __name,
    );
  }

  _dart_sysconf _sysconf;

  /// Get the value of the string-valued system variable NAME.
  int confstr(
    int __name,
    ffi.Pointer<ffi.Int8> __buf,
    int __len,
  ) {
    _confstr ??= _dylib.lookupFunction<_c_confstr, _dart_confstr>('confstr');
    return _confstr(
      __name,
      __buf,
      __len,
    );
  }

  _dart_confstr _confstr;

  /// Get the process ID of the calling process.
  int getpid() {
    _getpid ??= _dylib.lookupFunction<_c_getpid, _dart_getpid>('getpid');
    return _getpid();
  }

  _dart_getpid _getpid;

  /// Get the process ID of the calling process's parent.
  int getppid() {
    _getppid ??= _dylib.lookupFunction<_c_getppid, _dart_getppid>('getppid');
    return _getppid();
  }

  _dart_getppid _getppid;

  /// Get the process group ID of the calling process.
  int getpgrp() {
    _getpgrp ??= _dylib.lookupFunction<_c_getpgrp, _dart_getpgrp>('getpgrp');
    return _getpgrp();
  }

  _dart_getpgrp _getpgrp;

  int getpgid(
    int __pid,
  ) {
    _getpgid ??= _dylib.lookupFunction<_c_getpgid, _dart_getpgid>('getpgid');
    return _getpgid(
      __pid,
    );
  }

  _dart_getpgid _getpgid;

  /// Set the process group ID of the process matching PID to PGID.
  /// If PID is zero, the current process's process group ID is set.
  /// If PGID is zero, the process ID of the process is used.
  int setpgid(
    int __pid,
    int __pgid,
  ) {
    _setpgid ??= _dylib.lookupFunction<_c_setpgid, _dart_setpgid>('setpgid');
    return _setpgid(
      __pid,
      __pgid,
    );
  }

  _dart_setpgid _setpgid;

  /// Set the process group ID of the calling process to its own PID.
  /// This is exactly the same as `setpgid (0, 0)'.
  int setpgrp() {
    _setpgrp ??= _dylib.lookupFunction<_c_setpgrp, _dart_setpgrp>('setpgrp');
    return _setpgrp();
  }

  _dart_setpgrp _setpgrp;

  /// Create a new session with the calling process as its leader.
  /// The process group IDs of the session and the calling process
  /// are set to the process ID of the calling process, which is returned.
  int setsid() {
    _setsid ??= _dylib.lookupFunction<_c_setsid, _dart_setsid>('setsid');
    return _setsid();
  }

  _dart_setsid _setsid;

  /// Return the session ID of the given process.
  int getsid(
    int __pid,
  ) {
    _getsid ??= _dylib.lookupFunction<_c_getsid, _dart_getsid>('getsid');
    return _getsid(
      __pid,
    );
  }

  _dart_getsid _getsid;

  /// Get the real user ID of the calling process.
  int getuid() {
    _getuid ??= _dylib.lookupFunction<_c_getuid, _dart_getuid>('getuid');
    return _getuid();
  }

  _dart_getuid _getuid;

  /// Get the effective user ID of the calling process.
  int geteuid() {
    _geteuid ??= _dylib.lookupFunction<_c_geteuid, _dart_geteuid>('geteuid');
    return _geteuid();
  }

  _dart_geteuid _geteuid;

  /// Get the real group ID of the calling process.
  int getgid() {
    _getgid ??= _dylib.lookupFunction<_c_getgid, _dart_getgid>('getgid');
    return _getgid();
  }

  _dart_getgid _getgid;

  /// Get the effective group ID of the calling process.
  int getegid() {
    _getegid ??= _dylib.lookupFunction<_c_getegid, _dart_getegid>('getegid');
    return _getegid();
  }

  _dart_getegid _getegid;

  /// If SIZE is zero, return the number of supplementary groups
  /// the calling process is in.  Otherwise, fill in the group IDs
  /// of its supplementary groups in LIST and return the number written.
  int getgroups(
    int __size,
    ffi.Pointer<ffi.Uint32> __list,
  ) {
    _getgroups ??=
        _dylib.lookupFunction<_c_getgroups, _dart_getgroups>('getgroups');
    return _getgroups(
      __size,
      __list,
    );
  }

  _dart_getgroups _getgroups;

  /// Set the user ID of the calling process to UID.
  /// If the calling process is the super-user, set the real
  /// and effective user IDs, and the saved set-user-ID to UID;
  /// if not, the effective user ID is set to UID.
  int setuid(
    int __uid,
  ) {
    _setuid ??= _dylib.lookupFunction<_c_setuid, _dart_setuid>('setuid');
    return _setuid(
      __uid,
    );
  }

  _dart_setuid _setuid;

  /// Set the real user ID of the calling process to RUID,
  /// and the effective user ID of the calling process to EUID.
  int setreuid(
    int __ruid,
    int __euid,
  ) {
    _setreuid ??=
        _dylib.lookupFunction<_c_setreuid, _dart_setreuid>('setreuid');
    return _setreuid(
      __ruid,
      __euid,
    );
  }

  _dart_setreuid _setreuid;

  /// Set the effective user ID of the calling process to UID.
  int seteuid(
    int __uid,
  ) {
    _seteuid ??= _dylib.lookupFunction<_c_seteuid, _dart_seteuid>('seteuid');
    return _seteuid(
      __uid,
    );
  }

  _dart_seteuid _seteuid;

  /// Set the group ID of the calling process to GID.
  /// If the calling process is the super-user, set the real
  /// and effective group IDs, and the saved set-group-ID to GID;
  /// if not, the effective group ID is set to GID.
  int setgid(
    int __gid,
  ) {
    _setgid ??= _dylib.lookupFunction<_c_setgid, _dart_setgid>('setgid');
    return _setgid(
      __gid,
    );
  }

  _dart_setgid _setgid;

  /// Set the real group ID of the calling process to RGID,
  /// and the effective group ID of the calling process to EGID.
  int setregid(
    int __rgid,
    int __egid,
  ) {
    _setregid ??=
        _dylib.lookupFunction<_c_setregid, _dart_setregid>('setregid');
    return _setregid(
      __rgid,
      __egid,
    );
  }

  _dart_setregid _setregid;

  /// Set the effective group ID of the calling process to GID.
  int setegid(
    int __gid,
  ) {
    _setegid ??= _dylib.lookupFunction<_c_setegid, _dart_setegid>('setegid');
    return _setegid(
      __gid,
    );
  }

  _dart_setegid _setegid;

  /// Clone the calling process, creating an exact copy.
  /// Return -1 for errors, 0 to the new process,
  /// and the process ID of the new process to the old process.
  int fork() {
    _fork ??= _dylib.lookupFunction<_c_fork, _dart_fork>('fork');
    return _fork();
  }

  _dart_fork _fork;

  /// Clone the calling process, but without copying the whole address space.
  /// The calling process is suspended until the new process exits or is
  /// replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
  /// and the process ID of the new process to the old process.
  int vfork() {
    _vfork ??= _dylib.lookupFunction<_c_vfork, _dart_vfork>('vfork');
    return _vfork();
  }

  _dart_vfork _vfork;

  /// Return the pathname of the terminal FD is open on, or NULL on errors.
  /// The returned storage is good only until the next call to this function.
  ffi.Pointer<ffi.Int8> ttyname(
    int __fd,
  ) {
    _ttyname ??= _dylib.lookupFunction<_c_ttyname, _dart_ttyname>('ttyname');
    return _ttyname(
      __fd,
    );
  }

  _dart_ttyname _ttyname;

  /// Store at most BUFLEN characters of the pathname of the terminal FD is
  /// open on in BUF.  Return 0 on success, otherwise an error number.
  int ttyname_r(
    int __fd,
    ffi.Pointer<ffi.Int8> __buf,
    int __buflen,
  ) {
    _ttyname_r ??=
        _dylib.lookupFunction<_c_ttyname_r, _dart_ttyname_r>('ttyname_r');
    return _ttyname_r(
      __fd,
      __buf,
      __buflen,
    );
  }

  _dart_ttyname_r _ttyname_r;

  /// Return 1 if FD is a valid descriptor associated
  /// with a terminal, zero if not.
  int isatty(
    int fd,
  ) {
    _isatty ??= _dylib.lookupFunction<_c_isatty, _dart_isatty>('isatty');
    return _isatty(
      fd,
    );
  }

  _dart_isatty _isatty;

  /// Return the index into the active-logins file (utmp) for
  /// the controlling terminal.
  int ttyslot() {
    _ttyslot ??= _dylib.lookupFunction<_c_ttyslot, _dart_ttyslot>('ttyslot');
    return _ttyslot();
  }

  _dart_ttyslot _ttyslot;

  /// Make a link to FROM named TO.
  int link(
    ffi.Pointer<ffi.Int8> __from,
    ffi.Pointer<ffi.Int8> __to,
  ) {
    _link ??= _dylib.lookupFunction<_c_link, _dart_link>('link');
    return _link(
      __from,
      __to,
    );
  }

  _dart_link _link;

  /// Like link but relative paths in TO and FROM are interpreted relative
  /// to FROMFD and TOFD respectively.
  int linkat(
    int __fromfd,
    ffi.Pointer<ffi.Int8> __from,
    int __tofd,
    ffi.Pointer<ffi.Int8> __to,
    int __flags,
  ) {
    _linkat ??= _dylib.lookupFunction<_c_linkat, _dart_linkat>('linkat');
    return _linkat(
      __fromfd,
      __from,
      __tofd,
      __to,
      __flags,
    );
  }

  _dart_linkat _linkat;

  /// Make a symbolic link to FROM named TO.
  int symlink(
    ffi.Pointer<ffi.Int8> __from,
    ffi.Pointer<ffi.Int8> __to,
  ) {
    _symlink ??= _dylib.lookupFunction<_c_symlink, _dart_symlink>('symlink');
    return _symlink(
      __from,
      __to,
    );
  }

  _dart_symlink _symlink;

  /// Read the contents of the symbolic link PATH into no more than
  /// LEN bytes of BUF.  The contents are not null-terminated.
  /// Returns the number of characters read, or -1 for errors.
  int readlink(
    ffi.Pointer<ffi.Int8> __path,
    ffi.Pointer<ffi.Int8> __buf,
    int __len,
  ) {
    _readlink ??=
        _dylib.lookupFunction<_c_readlink, _dart_readlink>('readlink');
    return _readlink(
      __path,
      __buf,
      __len,
    );
  }

  _dart_readlink _readlink;

  /// Like symlink but a relative path in TO is interpreted relative to TOFD.
  int symlinkat(
    ffi.Pointer<ffi.Int8> __from,
    int __tofd,
    ffi.Pointer<ffi.Int8> __to,
  ) {
    _symlinkat ??=
        _dylib.lookupFunction<_c_symlinkat, _dart_symlinkat>('symlinkat');
    return _symlinkat(
      __from,
      __tofd,
      __to,
    );
  }

  _dart_symlinkat _symlinkat;

  /// Like readlink but a relative PATH is interpreted relative to FD.
  int readlinkat(
    int __fd,
    ffi.Pointer<ffi.Int8> __path,
    ffi.Pointer<ffi.Int8> __buf,
    int __len,
  ) {
    _readlinkat ??=
        _dylib.lookupFunction<_c_readlinkat, _dart_readlinkat>('readlinkat');
    return _readlinkat(
      __fd,
      __path,
      __buf,
      __len,
    );
  }

  _dart_readlinkat _readlinkat;

  /// Remove the link NAME.
  int unlink(
    ffi.Pointer<ffi.Int8> __name,
  ) {
    _unlink ??= _dylib.lookupFunction<_c_unlink, _dart_unlink>('unlink');
    return _unlink(
      __name,
    );
  }

  _dart_unlink _unlink;

  /// Remove the link NAME relative to FD.
  int unlinkat(
    int __fd,
    ffi.Pointer<ffi.Int8> __name,
    int __flag,
  ) {
    _unlinkat ??=
        _dylib.lookupFunction<_c_unlinkat, _dart_unlinkat>('unlinkat');
    return _unlinkat(
      __fd,
      __name,
      __flag,
    );
  }

  _dart_unlinkat _unlinkat;

  /// Remove the directory PATH.
  int rmdir(
    ffi.Pointer<ffi.Int8> __path,
  ) {
    _rmdir ??= _dylib.lookupFunction<_c_rmdir, _dart_rmdir>('rmdir');
    return _rmdir(
      __path,
    );
  }

  _dart_rmdir _rmdir;

  /// Return the foreground process group ID of FD.
  int tcgetpgrp(
    int __fd,
  ) {
    _tcgetpgrp ??=
        _dylib.lookupFunction<_c_tcgetpgrp, _dart_tcgetpgrp>('tcgetpgrp');
    return _tcgetpgrp(
      __fd,
    );
  }

  _dart_tcgetpgrp _tcgetpgrp;

  /// Set the foreground process group ID of FD set PGRP_ID.
  int tcsetpgrp(
    int __fd,
    int __pgrp_id,
  ) {
    _tcsetpgrp ??=
        _dylib.lookupFunction<_c_tcsetpgrp, _dart_tcsetpgrp>('tcsetpgrp');
    return _tcsetpgrp(
      __fd,
      __pgrp_id,
    );
  }

  _dart_tcsetpgrp _tcsetpgrp;

  /// Return the login name of the user.
  ///
  /// This function is a possible cancellation point and therefore not
  /// marked with __THROW.
  ffi.Pointer<ffi.Int8> getlogin() {
    _getlogin ??=
        _dylib.lookupFunction<_c_getlogin, _dart_getlogin>('getlogin');
    return _getlogin();
  }

  _dart_getlogin _getlogin;

  /// Return at most NAME_LEN characters of the login name of the user in NAME.
  /// If it cannot be determined or some other error occurred, return the error
  /// code.  Otherwise return 0.
  ///
  /// This function is a possible cancellation point and therefore not
  /// marked with __THROW.
  int getlogin_r(
    ffi.Pointer<ffi.Int8> __name,
    int __name_len,
  ) {
    _getlogin_r ??=
        _dylib.lookupFunction<_c_getlogin_r, _dart_getlogin_r>('getlogin_r');
    return _getlogin_r(
      __name,
      __name_len,
    );
  }

  _dart_getlogin_r _getlogin_r;

  /// Set the login name returned by `getlogin'.
  int setlogin(
    ffi.Pointer<ffi.Int8> __name,
  ) {
    _setlogin ??=
        _dylib.lookupFunction<_c_setlogin, _dart_setlogin>('setlogin');
    return _setlogin(
      __name,
    );
  }

  _dart_setlogin _setlogin;

  int getopt(
    int ___argc,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> ___argv,
    ffi.Pointer<ffi.Int8> __shortopts,
  ) {
    _getopt ??= _dylib.lookupFunction<_c_getopt, _dart_getopt>('getopt');
    return _getopt(
      ___argc,
      ___argv,
      __shortopts,
    );
  }

  _dart_getopt _getopt;

  /// Put the name of the current host in no more than LEN bytes of NAME.
  /// The result is null-terminated if LEN is large enough for the full
  /// name and the terminator.
  int gethostname(
    ffi.Pointer<ffi.Int8> __name,
    int __len,
  ) {
    _gethostname ??=
        _dylib.lookupFunction<_c_gethostname, _dart_gethostname>('gethostname');
    return _gethostname(
      __name,
      __len,
    );
  }

  _dart_gethostname _gethostname;

  /// Set the name of the current host to NAME, which is LEN bytes long.
  /// This call is restricted to the super-user.
  int sethostname(
    ffi.Pointer<ffi.Int8> __name,
    int __len,
  ) {
    _sethostname ??=
        _dylib.lookupFunction<_c_sethostname, _dart_sethostname>('sethostname');
    return _sethostname(
      __name,
      __len,
    );
  }

  _dart_sethostname _sethostname;

  /// Set the current machine's Internet number to ID.
  /// This call is restricted to the super-user.
  int sethostid(
    int __id,
  ) {
    _sethostid ??=
        _dylib.lookupFunction<_c_sethostid, _dart_sethostid>('sethostid');
    return _sethostid(
      __id,
    );
  }

  _dart_sethostid _sethostid;

  /// Get and set the NIS (aka YP) domain name, if any.
  /// Called just like `gethostname' and `sethostname'.
  /// The NIS domain name is usually the empty string when not using NIS.
  int getdomainname(
    ffi.Pointer<ffi.Int8> __name,
    int __len,
  ) {
    _getdomainname ??= _dylib
        .lookupFunction<_c_getdomainname, _dart_getdomainname>('getdomainname');
    return _getdomainname(
      __name,
      __len,
    );
  }

  _dart_getdomainname _getdomainname;

  int setdomainname(
    ffi.Pointer<ffi.Int8> __name,
    int __len,
  ) {
    _setdomainname ??= _dylib
        .lookupFunction<_c_setdomainname, _dart_setdomainname>('setdomainname');
    return _setdomainname(
      __name,
      __len,
    );
  }

  _dart_setdomainname _setdomainname;

  /// Revoke access permissions to all processes currently communicating
  /// with the control terminal, and then send a SIGHUP signal to the process
  /// group of the control terminal.
  int vhangup() {
    _vhangup ??= _dylib.lookupFunction<_c_vhangup, _dart_vhangup>('vhangup');
    return _vhangup();
  }

  _dart_vhangup _vhangup;

  /// Revoke the access of all descriptors currently open on FILE.
  int revoke(
    ffi.Pointer<ffi.Int8> __file,
  ) {
    _revoke ??= _dylib.lookupFunction<_c_revoke, _dart_revoke>('revoke');
    return _revoke(
      __file,
    );
  }

  _dart_revoke _revoke;

  /// Enable statistical profiling, writing samples of the PC into at most
  /// SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
  /// is enabled, the system examines the user PC and increments
  /// SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
  /// disable profiling.  Returns zero on success, -1 on error.
  int profil(
    ffi.Pointer<ffi.Uint16> __sample_buffer,
    int __size,
    int __offset,
    int __scale,
  ) {
    _profil ??= _dylib.lookupFunction<_c_profil, _dart_profil>('profil');
    return _profil(
      __sample_buffer,
      __size,
      __offset,
      __scale,
    );
  }

  _dart_profil _profil;

  /// Turn accounting on if NAME is an existing file.  The system will then write
  /// a record for each process as it terminates, to this file.  If NAME is NULL,
  /// turn accounting off.  This call is restricted to the super-user.
  int acct(
    ffi.Pointer<ffi.Int8> __name,
  ) {
    _acct ??= _dylib.lookupFunction<_c_acct, _dart_acct>('acct');
    return _acct(
      __name,
    );
  }

  _dart_acct _acct;

  /// Successive calls return the shells listed in `/etc/shells'.
  ffi.Pointer<ffi.Int8> getusershell() {
    _getusershell ??= _dylib
        .lookupFunction<_c_getusershell, _dart_getusershell>('getusershell');
    return _getusershell();
  }

  _dart_getusershell _getusershell;

  void endusershell() {
    _endusershell ??= _dylib
        .lookupFunction<_c_endusershell, _dart_endusershell>('endusershell');
    return _endusershell();
  }

  _dart_endusershell _endusershell;

  void setusershell() {
    _setusershell ??= _dylib
        .lookupFunction<_c_setusershell, _dart_setusershell>('setusershell');
    return _setusershell();
  }

  _dart_setusershell _setusershell;

  /// Put the program in the background, and dissociate from the controlling
  /// terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
  /// redirects stdin, stdout, and stderr to /dev/null.
  int daemon(
    int __nochdir,
    int __noclose,
  ) {
    _daemon ??= _dylib.lookupFunction<_c_daemon, _dart_daemon>('daemon');
    return _daemon(
      __nochdir,
      __noclose,
    );
  }

  _dart_daemon _daemon;

  /// Make PATH be the root directory (the starting point for absolute paths).
  /// This call is restricted to the super-user.
  int chroot(
    ffi.Pointer<ffi.Int8> __path,
  ) {
    _chroot ??= _dylib.lookupFunction<_c_chroot, _dart_chroot>('chroot');
    return _chroot(
      __path,
    );
  }

  _dart_chroot _chroot;

  /// Prompt with PROMPT and read a string from the terminal without echoing.
  /// Uses /dev/tty if possible; otherwise stderr and stdin.
  ffi.Pointer<ffi.Int8> getpass(
    ffi.Pointer<ffi.Int8> __prompt,
  ) {
    _getpass ??= _dylib.lookupFunction<_c_getpass, _dart_getpass>('getpass');
    return _getpass(
      __prompt,
    );
  }

  _dart_getpass _getpass;

  /// Make all changes done to FD actually appear on disk.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int fsync(
    int __fd,
  ) {
    _fsync ??= _dylib.lookupFunction<_c_fsync, _dart_fsync>('fsync');
    return _fsync(
      __fd,
    );
  }

  _dart_fsync _fsync;

  /// Return identifier for the current host.
  int gethostid() {
    _gethostid ??=
        _dylib.lookupFunction<_c_gethostid, _dart_gethostid>('gethostid');
    return _gethostid();
  }

  _dart_gethostid _gethostid;

  /// Make all changes done to all files actually appear on disk.
  void sync_1() {
    _sync_1 ??= _dylib.lookupFunction<_c_sync_1, _dart_sync_1>('sync');
    return _sync_1();
  }

  _dart_sync_1 _sync_1;

  /// Return the number of bytes in a page.  This is the system's page size,
  /// which is not necessarily the same as the hardware page size.
  int getpagesize() {
    _getpagesize ??=
        _dylib.lookupFunction<_c_getpagesize, _dart_getpagesize>('getpagesize');
    return _getpagesize();
  }

  _dart_getpagesize _getpagesize;

  /// Return the maximum number of file descriptors
  /// the current process could possibly have.
  int getdtablesize() {
    _getdtablesize ??= _dylib
        .lookupFunction<_c_getdtablesize, _dart_getdtablesize>('getdtablesize');
    return _getdtablesize();
  }

  _dart_getdtablesize _getdtablesize;

  int truncate(
    ffi.Pointer<ffi.Int8> __file,
    int __length,
  ) {
    _truncate ??=
        _dylib.lookupFunction<_c_truncate, _dart_truncate>('truncate');
    return _truncate(
      __file,
      __length,
    );
  }

  _dart_truncate _truncate;

  int ftruncate(
    int __fd,
    int __length,
  ) {
    _ftruncate ??=
        _dylib.lookupFunction<_c_ftruncate, _dart_ftruncate>('ftruncate');
    return _ftruncate(
      __fd,
      __length,
    );
  }

  _dart_ftruncate _ftruncate;

  /// Set the end of accessible data space (aka "the break") to ADDR.
  /// Returns zero on success and -1 for errors (with errno set).
  int brk(
    ffi.Pointer<ffi.Void> __addr,
  ) {
    _brk ??= _dylib.lookupFunction<_c_brk, _dart_brk>('brk');
    return _brk(
      __addr,
    );
  }

  _dart_brk _brk;

  /// Increase or decrease the end of accessible data space by DELTA bytes.
  /// If successful, returns the address the previous end of data space
  /// (i.e. the beginning of the new space, if DELTA > 0);
  /// returns (void *) -1 for errors (with errno set).
  ffi.Pointer<ffi.Void> sbrk(
    int __delta,
  ) {
    _sbrk ??= _dylib.lookupFunction<_c_sbrk, _dart_sbrk>('sbrk');
    return _sbrk(
      __delta,
    );
  }

  _dart_sbrk _sbrk;

  /// Invoke `system call' number SYSNO, passing it the remaining arguments.
  /// This is completely system-dependent, and not often useful.
  ///
  /// In Unix, `syscall' sets `errno' for all errors and most calls return -1
  /// for errors; in many systems you cannot pass arguments or get return
  /// values for all system calls (`pipe', `fork', and `getppid' typically
  /// among them).
  ///
  /// In Mach, all system calls take normal arguments and always return an
  /// error code (zero for success).
  int syscall(
    int __sysno,
  ) {
    _syscall ??= _dylib.lookupFunction<_c_syscall, _dart_syscall>('syscall');
    return _syscall(
      __sysno,
    );
  }

  _dart_syscall _syscall;

  int lockf(
    int __fd,
    int __cmd,
    int __len,
  ) {
    _lockf ??= _dylib.lookupFunction<_c_lockf, _dart_lockf>('lockf');
    return _lockf(
      __fd,
      __cmd,
      __len,
    );
  }

  _dart_lockf _lockf;

  /// Synchronize at least the data part of a file with the underlying
  /// media.
  int fdatasync(
    int __fildes,
  ) {
    _fdatasync ??=
        _dylib.lookupFunction<_c_fdatasync, _dart_fdatasync>('fdatasync');
    return _fdatasync(
      __fildes,
    );
  }

  _dart_fdatasync _fdatasync;

  /// One-way hash PHRASE, returning a string suitable for storage in the
  /// user database.  SALT selects the one-way function to use, and
  /// ensures that no two users' hashes are the same, even if they use
  /// the same passphrase.  The return value points to static storage
  /// which will be overwritten by the next call to crypt.
  ffi.Pointer<ffi.Int8> crypt(
    ffi.Pointer<ffi.Int8> __key,
    ffi.Pointer<ffi.Int8> __salt,
  ) {
    _crypt ??= _dylib.lookupFunction<_c_crypt, _dart_crypt>('crypt');
    return _crypt(
      __key,
      __salt,
    );
  }

  _dart_crypt _crypt;

  /// Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on
  /// success or -1 on error.
  int getentropy(
    ffi.Pointer<ffi.Void> __buffer,
    int __length,
  ) {
    _getentropy ??=
        _dylib.lookupFunction<_c_getentropy, _dart_getentropy>('getentropy');
    return _getentropy(
      __buffer,
      __length,
    );
  }

  _dart_getentropy _getentropy;
}

const int NULL = 0;

const int R_OK = 4;

const int W_OK = 2;

const int X_OK = 1;

const int F_OK = 0;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int L_SET = 0;

const int L_INCR = 1;

const int L_XTND = 2;

const int F_ULOCK = 0;

const int F_LOCK = 1;

const int F_TLOCK = 2;

const int F_TEST = 3;

const int PATH_MAX = 4096;

typedef _c_access = ffi.Int32 Function(
  ffi.Pointer<Utf8> __name,
  ffi.Int32 __type,
);

typedef _dart_access = int Function(
  ffi.Pointer<Utf8> __name,
  int __type,
);

typedef _c_faccessat = ffi.Int32 Function(
  ffi.Int32 __fd,
  ffi.Pointer<Utf8> __file,
  ffi.Int32 __type,
  ffi.Int32 __flag,
);

typedef _dart_faccessat = int Function(
  int __fd,
  ffi.Pointer<Utf8> __file,
  int __type,
  int __flag,
);

typedef _c_lseek = ffi.Int64 Function(
  ffi.Int32 __fd,
  ffi.Int64 __offset,
  ffi.Int32 __whence,
);

typedef _dart_lseek = int Function(
  int __fd,
  int __offset,
  int __whence,
);

typedef _c_close = ffi.Int32 Function(
  ffi.Int32 __fd,
);

typedef _dart_close = int Function(
  int __fd,
);

typedef _c_read = ffi.Int64 Function(
  ffi.Int32 __fd,
  ffi.Pointer<ffi.Void> __buf,
  ffi.Uint64 __nbytes,
);

typedef _dart_read = int Function(
  int __fd,
  ffi.Pointer<ffi.Void> __buf,
  int __nbytes,
);

typedef _c_write = ffi.Int64 Function(
  ffi.Int32 __fd,
  ffi.Pointer<ffi.Void> __buf,
  ffi.Uint64 __n,
);

typedef _dart_write = int Function(
  int __fd,
  ffi.Pointer<ffi.Void> __buf,
  int __n,
);

typedef _c_pread = ffi.Int64 Function(
  ffi.Int32 __fd,
  ffi.Pointer<ffi.Void> __buf,
  ffi.Uint64 __nbytes,
  ffi.Int64 __offset,
);

typedef _dart_pread = int Function(
  int __fd,
  ffi.Pointer<ffi.Void> __buf,
  int __nbytes,
  int __offset,
);

typedef _c_pwrite = ffi.Int64 Function(
  ffi.Int32 __fd,
  ffi.Pointer<ffi.Void> __buf,
  ffi.Uint64 __n,
  ffi.Int64 __offset,
);

typedef _dart_pwrite = int Function(
  int __fd,
  ffi.Pointer<ffi.Void> __buf,
  int __n,
  int __offset,
);

typedef _c_pipe = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> __pipedes,
);

typedef _dart_pipe = int Function(
  ffi.Pointer<ffi.Int32> __pipedes,
);

typedef _c_alarm = ffi.Uint32 Function(
  ffi.Uint32 __seconds,
);

typedef _dart_alarm = int Function(
  int __seconds,
);

typedef _c_sleep = ffi.Uint32 Function(
  ffi.Uint32 __seconds,
);

typedef _dart_sleep = int Function(
  int __seconds,
);

typedef _c_ualarm = ffi.Uint32 Function(
  ffi.Uint32 __value,
  ffi.Uint32 __interval,
);

typedef _dart_ualarm = int Function(
  int __value,
  int __interval,
);

typedef _c_usleep = ffi.Int32 Function(
  ffi.Uint32 __useconds,
);

typedef _dart_usleep = int Function(
  int __useconds,
);

typedef _c_pause = ffi.Int32 Function();

typedef _dart_pause = int Function();

typedef _c_chown = ffi.Int32 Function(
  ffi.Pointer<Utf8> __file,
  ffi.Uint32 __owner,
  ffi.Uint32 __group,
);

typedef _dart_chown = int Function(
  ffi.Pointer<Utf8> __file,
  int __owner,
  int __group,
);

typedef _c_fchown = ffi.Int32 Function(
  ffi.Int32 __fd,
  ffi.Uint32 __owner,
  ffi.Uint32 __group,
);

typedef _dart_fchown = int Function(
  int __fd,
  int __owner,
  int __group,
);

typedef _c_lchown = ffi.Int32 Function(
  ffi.Pointer<Utf8> __file,
  ffi.Uint32 __owner,
  ffi.Uint32 __group,
);

typedef _dart_lchown = int Function(
  ffi.Pointer<Utf8> __file,
  int __owner,
  int __group,
);

typedef _c_fchownat = ffi.Int32 Function(
  ffi.Int32 __fd,
  ffi.Pointer<Utf8> __file,
  ffi.Uint32 __owner,
  ffi.Uint32 __group,
  ffi.Int32 __flag,
);

typedef _dart_fchownat = int Function(
  int __fd,
  ffi.Pointer<Utf8> __file,
  int __owner,
  int __group,
  int __flag,
);

typedef _c_chdir = ffi.Int32 Function(
  ffi.Pointer<Utf8> __path,
);

typedef _dart_chdir = int Function(
  ffi.Pointer<Utf8> __path,
);

typedef _c_fchdir = ffi.Int32 Function(
  ffi.Int32 __fd,
);

typedef _dart_fchdir = int Function(
  int __fd,
);

typedef _c_getcwd = ffi.Pointer<Utf8> Function(
  ffi.Pointer<Utf8> __buf,
  ffi.Uint64 __size,
);

typedef _dart_getcwd = ffi.Pointer<Utf8> Function(
  ffi.Pointer<Utf8> __buf,
  int __size,
);

typedef _c_getwd = ffi.Pointer<Utf8> Function(
  ffi.Pointer<Utf8> __buf,
);

typedef _dart_getwd = ffi.Pointer<Utf8> Function(
  ffi.Pointer<Utf8> __buf,
);

typedef _c_dup = ffi.Int32 Function(
  ffi.Int32 __fd,
);

typedef _dart_dup = int Function(
  int __fd,
);

typedef _c_dup2 = ffi.Int32 Function(
  ffi.Int32 __fd,
  ffi.Int32 __fd2,
);

typedef _dart_dup2 = int Function(
  int __fd,
  int __fd2,
);

typedef _c_execve = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __envp,
);

typedef _dart_execve = int Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __envp,
);

typedef _c_fexecve = ffi.Int32 Function(
  ffi.Int32 __fd,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __envp,
);

typedef _dart_fexecve = int Function(
  int __fd,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __envp,
);

typedef _c_execv = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
);

typedef _dart_execv = int Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
);

typedef _c_execle = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Int8> __arg,
);

typedef _dart_execle = int Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Int8> __arg,
);

typedef _c_execl = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Int8> __arg,
);

typedef _dart_execl = int Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Int8> __arg,
);

typedef _c_execvp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __file,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
);

typedef _dart_execvp = int Function(
  ffi.Pointer<ffi.Int8> __file,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __argv,
);

typedef _c_execlp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __file,
  ffi.Pointer<ffi.Int8> __arg,
);

typedef _dart_execlp = int Function(
  ffi.Pointer<ffi.Int8> __file,
  ffi.Pointer<ffi.Int8> __arg,
);

typedef _c_nice = ffi.Int32 Function(
  ffi.Int32 __inc,
);

typedef _dart_nice = int Function(
  int __inc,
);

typedef _c__exit = ffi.Void Function(
  ffi.Int32 __status,
);

typedef _dart__exit = void Function(
  int __status,
);

typedef _c_pathconf = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Int32 __name,
);

typedef _dart_pathconf = int Function(
  ffi.Pointer<ffi.Int8> __path,
  int __name,
);

typedef _c_fpathconf = ffi.Int64 Function(
  ffi.Int32 __fd,
  ffi.Int32 __name,
);

typedef _dart_fpathconf = int Function(
  int __fd,
  int __name,
);

typedef _c_sysconf = ffi.Int64 Function(
  ffi.Int32 __name,
);

typedef _dart_sysconf = int Function(
  int __name,
);

typedef _c_confstr = ffi.Uint64 Function(
  ffi.Int32 __name,
  ffi.Pointer<ffi.Int8> __buf,
  ffi.Uint64 __len,
);

typedef _dart_confstr = int Function(
  int __name,
  ffi.Pointer<ffi.Int8> __buf,
  int __len,
);

typedef _c_getpid = ffi.Int32 Function();

typedef _dart_getpid = int Function();

typedef _c_getppid = ffi.Int32 Function();

typedef _dart_getppid = int Function();

typedef _c_getpgrp = ffi.Int32 Function();

typedef _dart_getpgrp = int Function();

typedef _c_getpgid = ffi.Int32 Function(
  ffi.Int32 __pid,
);

typedef _dart_getpgid = int Function(
  int __pid,
);

typedef _c_setpgid = ffi.Int32 Function(
  ffi.Int32 __pid,
  ffi.Int32 __pgid,
);

typedef _dart_setpgid = int Function(
  int __pid,
  int __pgid,
);

typedef _c_setpgrp = ffi.Int32 Function();

typedef _dart_setpgrp = int Function();

typedef _c_setsid = ffi.Int32 Function();

typedef _dart_setsid = int Function();

typedef _c_getsid = ffi.Int32 Function(
  ffi.Int32 __pid,
);

typedef _dart_getsid = int Function(
  int __pid,
);

typedef _c_getuid = ffi.Uint32 Function();

typedef _dart_getuid = int Function();

typedef _c_geteuid = ffi.Uint32 Function();

typedef _dart_geteuid = int Function();

typedef _c_getgid = ffi.Uint32 Function();

typedef _dart_getgid = int Function();

typedef _c_getegid = ffi.Uint32 Function();

typedef _dart_getegid = int Function();

typedef _c_getgroups = ffi.Int32 Function(
  ffi.Int32 __size,
  ffi.Pointer<ffi.Uint32> __list,
);

typedef _dart_getgroups = int Function(
  int __size,
  ffi.Pointer<ffi.Uint32> __list,
);

typedef _c_setuid = ffi.Int32 Function(
  ffi.Uint32 __uid,
);

typedef _dart_setuid = int Function(
  int __uid,
);

typedef _c_setreuid = ffi.Int32 Function(
  ffi.Uint32 __ruid,
  ffi.Uint32 __euid,
);

typedef _dart_setreuid = int Function(
  int __ruid,
  int __euid,
);

typedef _c_seteuid = ffi.Int32 Function(
  ffi.Uint32 __uid,
);

typedef _dart_seteuid = int Function(
  int __uid,
);

typedef _c_setgid = ffi.Int32 Function(
  ffi.Uint32 __gid,
);

typedef _dart_setgid = int Function(
  int __gid,
);

typedef _c_setregid = ffi.Int32 Function(
  ffi.Uint32 __rgid,
  ffi.Uint32 __egid,
);

typedef _dart_setregid = int Function(
  int __rgid,
  int __egid,
);

typedef _c_setegid = ffi.Int32 Function(
  ffi.Uint32 __gid,
);

typedef _dart_setegid = int Function(
  int __gid,
);

typedef _c_fork = ffi.Int32 Function();

typedef _dart_fork = int Function();

typedef _c_vfork = ffi.Int32 Function();

typedef _dart_vfork = int Function();

typedef _c_ttyname = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 __fd,
);

typedef _dart_ttyname = ffi.Pointer<ffi.Int8> Function(
  int __fd,
);

typedef _c_ttyname_r = ffi.Int32 Function(
  ffi.Int32 __fd,
  ffi.Pointer<ffi.Int8> __buf,
  ffi.Uint64 __buflen,
);

typedef _dart_ttyname_r = int Function(
  int __fd,
  ffi.Pointer<ffi.Int8> __buf,
  int __buflen,
);

typedef _c_isatty = ffi.Int32 Function(
  ffi.Int32 __fd,
);

typedef _dart_isatty = int Function(
  int __fd,
);

typedef _c_ttyslot = ffi.Int32 Function();

typedef _dart_ttyslot = int Function();

typedef _c_link = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __from,
  ffi.Pointer<ffi.Int8> __to,
);

typedef _dart_link = int Function(
  ffi.Pointer<ffi.Int8> __from,
  ffi.Pointer<ffi.Int8> __to,
);

typedef _c_linkat = ffi.Int32 Function(
  ffi.Int32 __fromfd,
  ffi.Pointer<ffi.Int8> __from,
  ffi.Int32 __tofd,
  ffi.Pointer<ffi.Int8> __to,
  ffi.Int32 __flags,
);

typedef _dart_linkat = int Function(
  int __fromfd,
  ffi.Pointer<ffi.Int8> __from,
  int __tofd,
  ffi.Pointer<ffi.Int8> __to,
  int __flags,
);

typedef _c_symlink = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __from,
  ffi.Pointer<ffi.Int8> __to,
);

typedef _dart_symlink = int Function(
  ffi.Pointer<ffi.Int8> __from,
  ffi.Pointer<ffi.Int8> __to,
);

typedef _c_readlink = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Int8> __buf,
  ffi.Uint64 __len,
);

typedef _dart_readlink = int Function(
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Int8> __buf,
  int __len,
);

typedef _c_symlinkat = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __from,
  ffi.Int32 __tofd,
  ffi.Pointer<ffi.Int8> __to,
);

typedef _dart_symlinkat = int Function(
  ffi.Pointer<ffi.Int8> __from,
  int __tofd,
  ffi.Pointer<ffi.Int8> __to,
);

typedef _c_readlinkat = ffi.Int64 Function(
  ffi.Int32 __fd,
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Int8> __buf,
  ffi.Uint64 __len,
);

typedef _dart_readlinkat = int Function(
  int __fd,
  ffi.Pointer<ffi.Int8> __path,
  ffi.Pointer<ffi.Int8> __buf,
  int __len,
);

typedef _c_unlink = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _dart_unlink = int Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _c_unlinkat = ffi.Int32 Function(
  ffi.Int32 __fd,
  ffi.Pointer<ffi.Int8> __name,
  ffi.Int32 __flag,
);

typedef _dart_unlinkat = int Function(
  int __fd,
  ffi.Pointer<ffi.Int8> __name,
  int __flag,
);

typedef _c_rmdir = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __path,
);

typedef _dart_rmdir = int Function(
  ffi.Pointer<ffi.Int8> __path,
);

typedef _c_tcgetpgrp = ffi.Int32 Function(
  ffi.Int32 __fd,
);

typedef _dart_tcgetpgrp = int Function(
  int __fd,
);

typedef _c_tcsetpgrp = ffi.Int32 Function(
  ffi.Int32 __fd,
  ffi.Int32 __pgrp_id,
);

typedef _dart_tcsetpgrp = int Function(
  int __fd,
  int __pgrp_id,
);

typedef _c_getlogin = ffi.Pointer<ffi.Int8> Function();

typedef _dart_getlogin = ffi.Pointer<ffi.Int8> Function();

typedef _c_getlogin_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Uint64 __name_len,
);

typedef _dart_getlogin_r = int Function(
  ffi.Pointer<ffi.Int8> __name,
  int __name_len,
);

typedef _c_setlogin = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _dart_setlogin = int Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _c_getopt = ffi.Int32 Function(
  ffi.Int32 ___argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> ___argv,
  ffi.Pointer<ffi.Int8> __shortopts,
);

typedef _dart_getopt = int Function(
  int ___argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> ___argv,
  ffi.Pointer<ffi.Int8> __shortopts,
);

typedef _c_gethostname = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Uint64 __len,
);

typedef _dart_gethostname = int Function(
  ffi.Pointer<ffi.Int8> __name,
  int __len,
);

typedef _c_sethostname = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Uint64 __len,
);

typedef _dart_sethostname = int Function(
  ffi.Pointer<ffi.Int8> __name,
  int __len,
);

typedef _c_sethostid = ffi.Int32 Function(
  ffi.Int64 __id,
);

typedef _dart_sethostid = int Function(
  int __id,
);

typedef _c_getdomainname = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Uint64 __len,
);

typedef _dart_getdomainname = int Function(
  ffi.Pointer<ffi.Int8> __name,
  int __len,
);

typedef _c_setdomainname = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Uint64 __len,
);

typedef _dart_setdomainname = int Function(
  ffi.Pointer<ffi.Int8> __name,
  int __len,
);

typedef _c_vhangup = ffi.Int32 Function();

typedef _dart_vhangup = int Function();

typedef _c_revoke = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __file,
);

typedef _dart_revoke = int Function(
  ffi.Pointer<ffi.Int8> __file,
);

typedef _c_profil = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __sample_buffer,
  ffi.Uint64 __size,
  ffi.Uint64 __offset,
  ffi.Uint32 __scale,
);

typedef _dart_profil = int Function(
  ffi.Pointer<ffi.Uint16> __sample_buffer,
  int __size,
  int __offset,
  int __scale,
);

typedef _c_acct = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _dart_acct = int Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _c_getusershell = ffi.Pointer<ffi.Int8> Function();

typedef _dart_getusershell = ffi.Pointer<ffi.Int8> Function();

typedef _c_endusershell = ffi.Void Function();

typedef _dart_endusershell = void Function();

typedef _c_setusershell = ffi.Void Function();

typedef _dart_setusershell = void Function();

typedef _c_daemon = ffi.Int32 Function(
  ffi.Int32 __nochdir,
  ffi.Int32 __noclose,
);

typedef _dart_daemon = int Function(
  int __nochdir,
  int __noclose,
);

typedef _c_chroot = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __path,
);

typedef _dart_chroot = int Function(
  ffi.Pointer<ffi.Int8> __path,
);

typedef _c_getpass = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __prompt,
);

typedef _dart_getpass = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __prompt,
);

typedef _c_fsync = ffi.Int32 Function(
  ffi.Int32 __fd,
);

typedef _dart_fsync = int Function(
  int __fd,
);

typedef _c_gethostid = ffi.Int64 Function();

typedef _dart_gethostid = int Function();

typedef _c_sync_1 = ffi.Void Function();

typedef _dart_sync_1 = void Function();

typedef _c_getpagesize = ffi.Int32 Function();

typedef _dart_getpagesize = int Function();

typedef _c_getdtablesize = ffi.Int32 Function();

typedef _dart_getdtablesize = int Function();

typedef _c_truncate = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __file,
  ffi.Int64 __length,
);

typedef _dart_truncate = int Function(
  ffi.Pointer<ffi.Int8> __file,
  int __length,
);

typedef _c_ftruncate = ffi.Int32 Function(
  ffi.Int32 __fd,
  ffi.Int64 __length,
);

typedef _dart_ftruncate = int Function(
  int __fd,
  int __length,
);

typedef _c_brk = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> __addr,
);

typedef _dart_brk = int Function(
  ffi.Pointer<ffi.Void> __addr,
);

typedef _c_sbrk = ffi.Pointer<ffi.Void> Function(
  ffi.IntPtr __delta,
);

typedef _dart_sbrk = ffi.Pointer<ffi.Void> Function(
  int __delta,
);

typedef _c_syscall = ffi.Int64 Function(
  ffi.Int64 __sysno,
);

typedef _dart_syscall = int Function(
  int __sysno,
);

typedef _c_lockf = ffi.Int32 Function(
  ffi.Int32 __fd,
  ffi.Int32 __cmd,
  ffi.Int64 __len,
);

typedef _dart_lockf = int Function(
  int __fd,
  int __cmd,
  int __len,
);

typedef _c_fdatasync = ffi.Int32 Function(
  ffi.Int32 __fildes,
);

typedef _dart_fdatasync = int Function(
  int __fildes,
);

typedef _c_crypt = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __key,
  ffi.Pointer<ffi.Int8> __salt,
);

typedef _dart_crypt = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __key,
  ffi.Pointer<ffi.Int8> __salt,
);

typedef _c_getentropy = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> __buffer,
  ffi.Uint64 __length,
);

typedef _dart_getentropy = int Function(
  ffi.Pointer<ffi.Void> __buffer,
  int __length,
);
